<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"12tall.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="远程线程注入 文中代码多摘自Win32创建远程线程，仅作部分注释">
<meta property="og:type" content="article">
<meta property="og:title" content="DLL 注入相关">
<meta property="og:url" content="https://12tall.github.io/2022/08/03/dll-injection/index.html">
<meta property="og:site_name" content="12Tall">
<meta property="og:description" content="远程线程注入 文中代码多摘自Win32创建远程线程，仅作部分注释">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-03T00:00:00.000Z">
<meta property="article:modified_time" content="2025-06-08T23:47:47.915Z">
<meta property="article:author" content="12Tall">
<meta property="article:tag" content="win32">
<meta property="article:tag" content="c&#x2F;cpp">
<meta property="article:tag" content="远程线程">
<meta property="article:tag" content="注入">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://12tall.github.io/2022/08/03/dll-injection/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://12tall.github.io/2022/08/03/dll-injection/","path":"2022/08/03/dll-injection/","title":"DLL 注入相关"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>DLL 注入相关 | 12Tall</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha256-UF1fgpAiu3tPJN/uCqEUHNe7pnr+QR0SQDNfgglgtcM=" crossorigin="anonymous">
  <script class="next-config" data-name="katex" type="application/json">{"copy_tex_js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js","integrity":"sha256-Us54+rSGDSTvIhKKUs4kygE2ipA0RXpWWh0/zLqw3bs="}}</script>
  <script src="/js/third-party/math/katex.js" defer></script>


<meta name="google-site-verification" content="3aQNNP68nNwFEpraTCstOoM3rHiVonXxsdls54cyW9Q" />
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="12Tall" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">12Tall</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">12Tall's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5"><span class="nav-number">1.</span> <span class="nav-text"> 远程线程注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.1.</span> <span class="nav-text"> 注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8go-%E7%94%9F%E6%88%90%E7%9A%84dll"><span class="nav-number">2.</span> <span class="nav-text"> C 语言调用Go 生成的DLL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#golang-%E7%BC%96%E5%86%99http-%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.1.</span> <span class="nav-text"> golang 编写http 服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E7%BC%96%E5%86%99dll"><span class="nav-number">2.2.</span> <span class="nav-text"> c 编写dll</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dll-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">2.2.1.</span> <span class="nav-text"> dll 参数传递</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95"><span class="nav-number">2.3.</span> <span class="nav-text"> 调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5-2"><span class="nav-number">2.4.</span> <span class="nav-text"> 远程线程注入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">3.</span> <span class="nav-text"> 参考链接</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="12Tall"
      src="/images/logo.png">
  <p class="site-author-name" itemprop="name">12Tall</p>
  <div class="site-description" itemprop="description">蝉噪林逾静 鸟鸣山更幽</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">131</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">217</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/12tall" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;12tall" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fb.ouyang@outlook.com" title="E-Mail → mailto:fb.ouyang@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://12tall.github.io/2022/08/03/dll-injection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo.png">
      <meta itemprop="name" content="12Tall">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="12Tall">
      <meta itemprop="description" content="蝉噪林逾静 鸟鸣山更幽">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="DLL 注入相关 | 12Tall">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          DLL 注入相关
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-03 00:00:00" itemprop="dateCreated datePublished" datetime="2022-08-03T00:00:00+00:00">2022-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-08 23:47:47" itemprop="dateModified" datetime="2025-06-08T23:47:47+00:00">2025-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/c-cpp/" itemprop="url" rel="index"><span itemprop="name">c_cpp</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="远程线程注入"><a class="markdownIt-Anchor" href="#远程线程注入"></a> 远程线程注入</h2>
<p>文中代码多摘自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/DarkBright/p/10820582.html">Win32创建远程线程</a>，仅作部分注释</p>
<span id="more"></span>
<CodeGroup>
<CodeGroupItem title="宿主程序">
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

void Fun(void)
&#123;
    for(size_t i &#x3D; 0; i &lt; 10; i++)&#123;
        &#x2F;&#x2F; 打印函数地址
        &#x2F;&#x2F; __FUNCTION__: 获取函数名
        &#x2F;&#x2F; __FILE__: 获取文件名
        &#x2F;&#x2F; __LINE__: 获取行号
        printf(&quot;%s addr:0x%p\r\n&quot;, __FUNCTION__, Fun);
    &#125;         
&#125;

int main(int argc, char* argv[])
&#123;
    Fun();
    &#x2F;&#x2F;MessageBox(NULL, TEXT(&quot;执行完成!&quot;), TEXT(&quot;提示&quot;), MB_OK);

    getchar();  &#x2F;&#x2F; 暂停
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</CodeGroupItem>
<CodeGroupItem title="测试远程线程">  
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

&#x2F;&#x2F; 宿主进程中打印的函数地址
#define FUN_ADDR 0x0000000000401550

DWORD getPid(LPTSTR name);
int main(int argc, char *argv[])
&#123;

    HANDLE hProcess &#x3D; 0;
    HANDLE hThread;
    DWORD dwThread &#x3D; 0;

    &#x2F;&#x2F; 打开进程，第三个参数是进程目标进程ID
    hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, 8684);

    if (hProcess &#x3D;&#x3D; NULL)
    &#123;
        printf(&quot;can not open process&quot;);
        return -1;
    &#125;

    &#x2F;&#x2F; 开启远程线程
    hThread &#x3D; CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)FUN_ADDR, NULL, 0, &amp;dwThread);  
    &#x2F;**
    * hProcess：目标进程的句柄
    * lpThreadAttributes：安全描述符的结构体指针，填 NULL 即可
    * dwStackSize：要创建的远程线程的堆栈大小，一般填 0 使用默认大小
    * lpStartAddress：远程线程的执行体，也就是创建的线程要执行的过程函数
    * lpParameter：远程线程执行体的参数，与lpStartAddress 配合使用
    * dwCreationFlags：创建标志，一般填0
    * lpThreadId：线程ID的指针，用于接收远程线程创建成功后的ID
    *&#x2F;

    if (hThread &#x3D;&#x3D; NULL)
    &#123;
        printf(&quot;can not create remote thread&quot;);
        return -1;
    &#125;

    CloseHandle(hProcess);
    CloseHandle(hThread);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</CodeGroupItem>
<CodeGroupItem title="寄生程序">  
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

void func1()
&#123;
    &#x2F;&#x2F; 输出函数名及其地址
    printf(&quot;%s addr:0x%p\n&quot;, __FUNCTION__, func1);
&#125;

BOOL APIENTRY DllMain(HMODULE hModule,
                      DWORD ul_reason_for_call,
                      LPVOID lpReserved)
&#123;
    switch (ul_reason_for_call)
    &#123;
    case DLL_PROCESS_ATTACH:
        MessageBox(NULL, TEXT(&quot;DLL inject successfully&quot;), TEXT(&quot;Warning:&quot;), MB_OK);
        func1();
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    &#125;
    return TRUE;
&#125;
&#x2F;&#x2F; 执行 gcc .\mydll.c -shared -o mydll.dll 以生成动态链接库  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</CodeGroupItem>
<CodeGroupItem title="注入器">
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

&#x2F;&#x2F; 进程id  
#define Pid 26036
&#x2F;&#x2F; dll 可以用绝对路径，也可以用相对路径  
&#x2F;&#x2F; 但最好还是用绝对路径
#define DLL_NAME &quot;mydll.dll&quot;

int main(int argc, char *argv[])
&#123;
    HANDLE hProcess &#x3D; 0;
    HANDLE hThread;
    DWORD dwThread &#x3D; 0;

    &#x2F;&#x2F; 打开进程  
    hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, Pid);
    if (hProcess &#x3D;&#x3D; NULL)
    &#123;
        printf(&quot;can not open process&quot;);
        return -1;
    &#125;

    &#x2F;&#x2F; 在进程内存入dll 路径字符串  
    &#x2F;&#x2F; 即将&#96;my_dll.dll&#96; 字符串保存至进程空间
    PVOID pDllName &#x3D; VirtualAllocEx(hProcess, NULL, strlen(DLL_NAME) + 1, MEM_COMMIT, PAGE_READWRITE);
    if (pDllName &#x3D;&#x3D; NULL)
    &#123;
        printf(&quot;can not allocate memory for dll&quot;);
        return -1;
    &#125;
    &#x2F;&#x2F; 写入dll 名称
    SIZE_T lenDll &#x3D; 0;
    WriteProcessMemory(hProcess, pDllName, (BYTE *)DLL_NAME, strlen(DLL_NAME) + 1, &amp;lenDll);
    
    &#x2F;&#x2F; 获取Kernal32.dll 中的&#96;LoadLibraryA&#96; 方法
    HMODULE hModule &#x3D; GetModuleHandle(TEXT(&quot;Kernel32.dll&quot;));
    if (hModule &#x3D;&#x3D; NULL)
    &#123;
        printf(&quot;can not get &quot;);
        return -1;
    &#125;
    FARPROC func1 &#x3D; GetProcAddress(hModule, &quot;LoadLibraryA&quot;);
    
    &#x2F;&#x2F; 在开启远程线程时，执行LoadLibraryA，加载my_dll.dll
    hThread &#x3D; CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)func1, pDllName, 0, &amp;dwThread);
    if (hThread &#x3D;&#x3D; NULL)
    &#123;
        printf(&quot;can not create remote thread&quot;);
        return -1;
    &#125;

    CloseHandle(hProcess);
    CloseHandle(hThread);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</CodeGroupItem>
<CodeGroupItem title="根据进程名获取PID">
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;TlHelp32.h&gt;

DWORD GetPid(const char *strProcessName);

int main()
&#123;
    GetPid(&quot;host.exe&quot;);
    return 0;
&#125;

DWORD GetPid(const char *strProcessName)
&#123;
    PROCESSENTRY32 pe32;
    pe32.dwSize &#x3D; sizeof(PROCESSENTRY32);

    HANDLE hProcessSnap &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcessSnap &#x3D;&#x3D; INVALID_HANDLE_VALUE)
    &#123;
        printf(&quot;CreateToolhelp32Snapshot 调用失败.\n&quot;);
        return -1;
    &#125;

    BOOL bMore &#x3D; Process32First(hProcessSnap, &amp;pe32);

    while (bMore)
    &#123;
        &#x2F;&#x2F; 打印所有进程信息
        &#x2F;&#x2F; printf(&quot;Process Name: %s\n&quot;, pe32.szExeFile); 
        &#x2F;&#x2F; printf(&quot;Process Id: %u\n\n&quot;, pe32.th32ProcessID);
        if (lstrcmp(pe32.szExeFile, strProcessName) &#x3D;&#x3D; 0)
        &#123;
            break;
        &#125;

        bMore &#x3D; Process32Next(hProcessSnap, &amp;pe32);
    &#125;
    CloseHandle(hProcessSnap);

    return pe32.th32ProcessID;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</CodeGroupItem>
</CodeGroup>
<h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3>
<ol>
<li>对于32 位的目标进程，应当将源码编译为32 位的可执行程序然后注入。否则不会有任何结果；</li>
<li>对于MinGW 来说，仅支持32 位gcc；而Mingw64 仅支持64 位。虽然可以通过-m[32|64] 指定编译时的目标架构，但是会报异常。</li>
</ol>
<h2 id="c-语言调用go-生成的dll"><a class="markdownIt-Anchor" href="#c-语言调用go-生成的dll"></a> C 语言调用Go 生成的DLL</h2>
<p>事情的起因是<s>我想学黑</s>，最近在看dll 远程线程注入的文章。迫于C/C++ 写起来太过繁琐，就想着能不能通过C 调用golang 编译的dll，进而将C 作为胶水语言使用。于是就有了本文。<br />
目标：在<code>notepad.exe</code> 上启动一个简单的http 服务。<br />
环境：<code>Win10 Pro 64 位</code>、<code>MinGW-w64</code>、<code>golang 15.6</code></p>
<p>因为直接从头到尾开发的话，可能会让人看得一头雾水，我准备先从较小的模块开始写起。这也是一次完整的实践流程。</p>
<h3 id="golang-编写http-服务"><a class="markdownIt-Anchor" href="#golang-编写http-服务"></a> golang 编写http 服务</h3>
<p>代码参考自简书<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8f208a6596f7">go实现简单的http服务</a>，这里稍作修改：</p>
<pre class="line-numbers language-go&#123;19-29&#125;" data-language="go&#123;19-29&#125;"><code class="language-go&#123;19-29&#125;">&#x2F;&#x2F; http.go
package main

import &quot;C&quot;
import (
	&quot;fmt&quot;
	&quot;net&#x2F;http&quot;
)

&#x2F;&#x2F; http 请求处理函数
func sayHello(w http.ResponseWriter, r *http.Request) &#123;
	_, _ &#x3D; w.Write([]byte(&quot;Hello World!&quot;))
&#125;

&#x2F;&#x2F; 导出函数。在编译成DLL 后可被调用者发现  
&#x2F;&#x2F; 下面的注释必须有 &#x2F;&#x2F;export 函数名  
&#x2F;&#x2F; 其中导出函数名最好与原函数名保持一致 

&#x2F;&#x2F;export StartHttp
func StartHttp() &#123;
	http.HandleFunc(&quot;&#x2F;&quot;, sayHello)

	err :&#x3D; http.ListenAndServe(&quot;127.0.0.1:9999&quot;, nil)
	if err !&#x3D; nil &#123;
		fmt.Printf(&quot;Error: %v\n&quot;, err)
		return
	&#125;
	fmt.Printf(&quot;Listening: http:&#x2F;&#x2F;127.0.0.1:9000&quot;)
&#125;

func main() &#123;
    &#x2F;&#x2F; StartHttp();  &#x2F;&#x2F; 调试时取消这一行的注释  
    &#x2F;&#x2F; 编译时main 函数最好为空
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过以下命令进行调试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 注意调试时需要取消掉main 方法里面的注释</span>
go run .<span class="token punctuation">\</span>http.go  <span class="token comment"># 如果不出意外，访问`http://localhost:9999` 就能看到`Hello World!` 了  </span>

<span class="token comment"># 编译  </span>
go build <span class="token parameter variable">-buildmode</span><span class="token operator">=</span>c-shared <span class="token parameter variable">-o</span> http.dll .<span class="token punctuation">\</span>http.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译好后待用。</p>
<h3 id="c-编写dll"><a class="markdownIt-Anchor" href="#c-编写dll"></a> c 编写dll</h3>
<p>如果我们需要从远程线程注入上面的<code>http.dll</code> 是不行的，因为它没有显式的入口函数。需要用C/C++ 开发一个带入口函数的<code>loader.dll</code> 来包装一下。注入<code>loader.dll</code>，在<code>loader.dll</code> 初始化的过程中，加载并获取<code>http.dll</code> 内<code>StartHttp()</code> 函数的地址。注意，只获取地址就行了，不要执行，因为一旦执行就会引发程序死锁。这是本文的重点一。</p>
<h4 id="dll-参数传递"><a class="markdownIt-Anchor" href="#dll-参数传递"></a> dll 参数传递</h4>
<p>因为加载dll 时不能传入参数，所以我们需要在<code>loader.dll</code> 中开辟一块共享内存来存放从<code>http.dll</code> 获取到的<code>StartHttp()</code> 函数的句柄（可以理解为指针）。为什么要用共享内存，因为同一个dll 加载到不同的进程中的地址可能也是不一样的。这也是本文的重点二。</p>
<pre class="line-numbers language-c++&#123;4-13,47-51&#125;" data-language="c++&#123;4-13,47-51&#125;"><code class="language-c++&#123;4-13,47-51&#125;">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

&#x2F;&#x2F; 开辟共享内存的宏命令
#ifdef __GNUC__
HANDLE k __attribute__((section(&quot;.shared&quot;), shared)) &#x3D; NULL;
#endif
#ifdef _MSC_VER
#pragma data_seg(&quot;.shared&quot;)
HANDLE k &#x3D; NULL;
#pragma data_seg()
#pragma comment(linker, &quot;&#x2F;section:.shared,RWS&quot;)
#endif

typedef void (*StartHttp)();  &#x2F;&#x2F; 函数类型定义

HMODULE hHttp &#x3D; NULL;  &#x2F;&#x2F; 用来存放http.dll 句柄

BOOL APIENTRY DllMain(HMODULE hModule,
                      DWORD ul_reason_for_call,
                      LPVOID lpReserved)
&#123;
    switch (ul_reason_for_call)
    &#123;
    case DLL_PROCESS_ATTACH:
    &#123;
        &#x2F;&#x2F; 简化了一些一场判断
        hHttp &#x3D; LoadLibrary(&quot;http.dll&quot;);
        StartHttp startWorker &#x3D; (StartHttp)GetProcAddress(hHttp, &quot;StartHttp&quot;);
        k &#x3D; startWorker;  &#x2F;&#x2F; 将http.dll 中的StartHttp() 的句柄（指针）放入共享内存
        break;
    &#125;

    case DLL_PROCESS_DETACH:
    &#123;
        FreeLibrary(hHttp);  &#x2F;&#x2F; 进程结束时释放http.dll
        break;
    &#125;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    &#125;
    return TRUE;
&#125;

&#x2F;&#x2F; 导出函数，用于调用者获取共享内存中的变量
HANDLE GetHttpStarter()
&#123;
    return k;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果是直接调用<code>http.dll</code> 的话，是不需要这个C 语言中间层的。编译备用</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc .<span class="token punctuation">\</span>loader.c <span class="token parameter variable">-shared</span> <span class="token parameter variable">-o</span> .<span class="token punctuation">\</span>loader.dll<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h3>
<p>下面是通过C 语言调用<code>loader.dll</code> 进而调用<code>http.dll</code> 的例子。</p>
<pre class="line-numbers language-c++&#123;15-18&#125;" data-language="c++&#123;15-18&#125;"><code class="language-c++&#123;15-18&#125;">&#x2F;&#x2F; client.c  
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;memory.h&gt;

typedef void (*StartHttp)();  &#x2F;&#x2F; http.dll 中的到处方法类型
typedef HMODULE (*GetHttpStarter)();  &#x2F;&#x2F; loader.dll 中的导出方法类型

int main()
&#123;
    char *dllPath &#x3D; &quot;loader.dll&quot;;
    HMODULE hLoader &#x3D; NULL;

    hLoader &#x3D; LoadLibrary(&quot;loader.dll&quot;);
    GetHttpStarter getHttpStarter &#x3D; (GetHttpStarter)GetProcAddress(hLoader, &quot;GetHttpStarter&quot;);
    &#x2F;&#x2F; 获取loader.dll 中的到处方法
    StartHttp startHttp &#x3D; (StartHttp)getHttpStarter();
    &#x2F;&#x2F; 获取http.dll 中的导出方法
    startHttp();  &#x2F;&#x2F; 启动http 服务
    printf(&quot;^^\n&quot;);
    FreeLibrary(hLoader);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译，并且将<code>loader.dll</code>、<code>http.dll</code> 放在同一目录，然后执行</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc .<span class="token punctuation">\</span>client.c <span class="token parameter variable">-o</span> .<span class="token punctuation">\</span>client.exe  

.<span class="token punctuation">\</span>client.exe 
<span class="token comment"># 正常来说，访问`http://localshost:9999` 也是能看到`Hello World!` 的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="远程线程注入-2"><a class="markdownIt-Anchor" href="#远程线程注入-2"></a> 远程线程注入</h3>
<p>一般来说，<code>LoadLibrary</code> 函数会默认加载同目录下的dll 文件。由于我们是在目标进程中开启远程线程，那么在加载dll 文件时的默认目录就需要手工指定了，最好是绝对目录。</p>
<p>::: details Client.c</p>
<pre class="line-numbers language-c++&#123;15-19,&#125;" data-language="c++&#123;15-19,&#125;"><code class="language-c++&#123;15-19,&#125;">&#x2F;&#x2F; client.c  
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;TlHelp32.h&gt;
#include &lt;string.h&gt;

typedef void (*StartHttp)();
typedef HMODULE (*GetHttpStarter)();

DWORD GetProcIdByName(const char *sProcName);
void InjectDll(DWORD nPid, const char *sDllName);

int main(int argc, char *argv[])
&#123;
    &#x2F;&#x2F; 获取loader.dll 的绝对路径
    char dllPath[MAX_PATH],
        *dllName &#x3D; &quot;\\loader.dll&quot;;
    GetCurrentDirectory(MAX_PATH, dllPath);
    strncat(dllPath, dllName, strlen(dllName));

    &#x2F;&#x2F; 获取目标进程
    char *sTarget &#x3D; argv[1];
    int nPid &#x3D; 0;
    if (0 &#x3D;&#x3D; (nPid &#x3D; GetProcIdByName(sTarget)))
    &#123;
        printf(&quot;There is no process named %s\n&quot;, sTarget);
        exit(1);
    &#125;
    &#x2F;&#x2F; 第一次开启远程线程，注入loader.dll  
    &#x2F;&#x2F; 自动加载http.dll  
    InjectDll(nPid, dllPath);
    
    &#x2F;&#x2F; 客户端加载loader.dll 通过共享内存获取http.dll 中函数的实际位置
    HMODULE hLoader &#x3D; LoadLibrary(dllPath);
    GetHttpStarter getHttpStarter &#x3D; (GetHttpStarter)GetProcAddress(hLoader, &quot;GetHttpStarter&quot;);
    StartHttp startHttp &#x3D; (StartHttp)getHttpStarter();

    &#x2F;&#x2F; 第二次开启远程线程  
    &#x2F;&#x2F; 启动http 服务
    HANDLE hProcess &#x3D;OpenProcess(PROCESS_ALL_ACCESS, FALSE, nPid);
    HANDLE hThread;
    DWORD dwThread &#x3D; 0;
    hThread &#x3D; CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)startHttp, NULL, 0, &amp;dwThread);    
    CloseHandle(hProcess);
    CloseHandle(hThread);
    
    printf(&quot;^^\n&quot;);
    FreeLibrary(hLoader);
    return 0;
&#125;


&#x2F;&#x2F; 通过进程名获取进程Id
DWORD GetProcIdByName(const char *sProcName)
&#123;
    PROCESSENTRY32 pe32;
    pe32.dwSize &#x3D; sizeof(PROCESSENTRY32);

    HANDLE hProcessSnap &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcessSnap &#x3D;&#x3D; INVALID_HANDLE_VALUE)
    &#123;
        return -1;
    &#125;

    BOOL bMore &#x3D; Process32First(hProcessSnap, &amp;pe32);

    while (bMore)
    &#123;
        if (strcasecmp(pe32.szExeFile, sProcName) &#x3D;&#x3D; 0)
        &#123;
            return pe32.th32ProcessID;
        &#125;
        bMore &#x3D; Process32Next(hProcessSnap, &amp;pe32);
    &#125;
    CloseHandle(hProcessSnap);
    return 0;
&#125;

&#x2F;&#x2F; 将dll 注入目标进程
void InjectDll(DWORD nPid, const char *sDllName)
&#123;
    HANDLE hProcess &#x3D; 0;
    HANDLE hThread;
    DWORD dwThread &#x3D; 0;

    hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, nPid);
    if (hProcess &#x3D;&#x3D; NULL)
    &#123;
        printf(&quot;open process failed\n&quot;);
        CloseHandle(hProcess);
        exit(1);
    &#125;

    PVOID pDllName &#x3D; VirtualAllocEx(hProcess, NULL, strlen(sDllName) + 1, MEM_COMMIT, PAGE_READWRITE);
    if (pDllName &#x3D;&#x3D; NULL)
    &#123;
        printf(&quot;allocate memory for dll failed\n&quot;);
        CloseHandle(hProcess);
        exit(1);
    &#125;

    SIZE_T lenDll &#x3D; 0;
    WriteProcessMemory(hProcess, pDllName, (BYTE *)sDllName, strlen(sDllName) + 1, &amp;lenDll);

    &#x2F;&#x2F; 获取Kernal32.dll 中的&#96;LoadLibraryA&#96; 方法
    HMODULE hModule &#x3D; GetModuleHandle(TEXT(&quot;Kernel32.dll&quot;));
    if (hModule &#x3D;&#x3D; NULL)
    &#123;
        printf(&quot;Load Kernel32.dll failed\n&quot;);
        CloseHandle(hProcess);
        exit(1);
    &#125;
    FARPROC func1 &#x3D; GetProcAddress(hModule, &quot;LoadLibraryA&quot;);

    hThread &#x3D; CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)func1, pDllName, 0, &amp;dwThread);
    
    if (hThread &#x3D;&#x3D; 0)
    &#123;
        printf(&quot;create remote thread failed&quot;);
        CloseHandle(hProcess);
        CloseHandle(hThread);
        exit(1);
    &#125;

    CloseHandle(hProcess);
    CloseHandle(hThread);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>:::</p>
<p>同时<code>loader.dll</code> 在加载<code>http.dll</code> 时也需要绝对路径。</p>
<p>::: details loader.c</p>
<pre class="line-numbers language-c++&#123;29-35&#125;" data-language="c++&#123;29-35&#125;"><code class="language-c++&#123;29-35&#125;">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

#ifdef __GNUC__
HANDLE k __attribute__((section(&quot;.shared&quot;), shared)) &#x3D; NULL;
#endif
#ifdef _MSC_VER
#pragma data_seg(&quot;.shared&quot;)
HANDLE k &#x3D; NULL;
#pragma data_seg()
#pragma comment(linker, &quot;&#x2F;section:.shared,RWS&quot;)
#endif

typedef void (*StartHttp)();

HMODULE hHttp &#x3D; NULL;
char dllPath[MAX_PATH],
    *dllName &#x3D; &quot;loader.dll&quot;,
    *workerName &#x3D; &quot;http.dll&quot;;

BOOL APIENTRY DllMain(HMODULE hModule,
                      DWORD ul_reason_for_call,
                      LPVOID lpReserved)
&#123;
    switch (ul_reason_for_call)
    &#123;
    case DLL_PROCESS_ATTACH:
    &#123;
        &#x2F;&#x2F; 获取http.dll 的绝对路径
        int nameLen &#x3D; strlen(dllName) - 1;
        GetModuleFileName(hModule, dllPath, strlen(dllPath) - 1);
        int fullLen &#x3D; strlen(dllPath) - 1;
        memset(dllPath + fullLen - nameLen, &#39;\0&#39;, nameLen);
        strncat(dllPath, workerName, strlen(workerName));
        hHttp &#x3D; LoadLibrary(dllPath);

        &#x2F;&#x2F; hHttp &#x3D; LoadLibrary(&quot;http.dll&quot;);
        StartHttp startWorker &#x3D; (StartHttp)GetProcAddress(hHttp, &quot;StartHttp&quot;);
        k &#x3D; startWorker;
        break;
    &#125;

    case DLL_PROCESS_DETACH:
    &#123;
        FreeLibrary(hHttp);
        break;
    &#125;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    &#125;
    return TRUE;
&#125;

HANDLE GetHttpStarter()
&#123;
    return k;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>:::</p>
<p>重新编译，先启动<code>notepad.exe</code>，再执行<code>.\client.exe</code>。就能在<code>notepad.exe</code> 进程上创建一个<code>http</code> 服务，访问<code>http://localhost:9999/</code> 将会看到<code>Hello World!</code> 字样。大功告成！</p>
<p>本文可以说是这三天思考的成果，也可以说是这两年一直想搞定的东西（<s>干坏事儿</s>）。因为C 语言虽然执行效率比较高，但是开发效率却是太低了，对开发人员要求比较高。而很多专业工具只提供了C/C++（对，没有python） 的接口，如果用C 做胶水，而实际工作用其他带GC 的高级语言，则开发效率也会高不少。</p>
<h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2>
<ol>
<li>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/DarkBright/p/10820582.html">Win32创建远程线程</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/DarkBright/p/10821038.html">远程线程注入DLL</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangxuechao/p/11709366.html">Windows 获取进程ID</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/65304131/is-it-possible-to-load-a-go-dll-in-c-dll-on-windows?noredirect=1#comment115450808_65304131">Is it possible to load a go-dll in c-dll on Windows?</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices">Dynamic-Link Library Best Practices</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://forum.pellesc.de/index.php?topic=4725.0">Shared memory segment in a C++ Class Library (DLL) using #pragma data seg</a></p>
</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>12Tall
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://12tall.github.io/2022/08/03/dll-injection/" title="DLL 注入相关">https://12tall.github.io/2022/08/03/dll-injection/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/win32/" rel="tag"># win32</a>
              <a href="/tags/c-cpp/" rel="tag"># c/cpp</a>
              <a href="/tags/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B/" rel="tag"># 远程线程</a>
              <a href="/tags/%E6%B3%A8%E5%85%A5/" rel="tag"># 注入</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/08/03/mem-mgmt/" rel="prev" title="C 语言内存管理">
                  <i class="fa fa-angle-left"></i> C 语言内存管理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/08/03/eve-ng/" rel="next" title="Eve-Ng使用笔记">
                  Eve-Ng使用笔记 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  
  <div class="comments giscus-container">
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">12Tall</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">145k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:47</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"12Tall/12tall.github.io","repo_id":"MDEwOlJlcG9zaXRvcnkyOTY1NjE5MzU=","category":"General","category_id":"DIC_kwDOEa0tD84CXgDH","mapping":"pathname","strict":0,"reactions_enabled":1,"emit_metadata":1,"theme":"light","lang":"en","crossorigin":"anonymous","input_position":"bottom","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-strict'           : CONFIG.giscus.strict,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9670282672953561" crossorigin="anonymous"></script>
</body>
</html>
